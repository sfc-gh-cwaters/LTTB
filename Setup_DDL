-- ************************************** iot_unit
CREATE TABLE iot_unit
(
 unit_uid       integer NOT NULL,
 unit_name      varchar NOT NULL,
 unit_long_name varchar,
 category       varchar,
 dscr           varchar,
 dimension      varchar,

 CONSTRAINT PK_1 PRIMARY KEY ( unit_uid )
);

-- ************************************** iot_base_second
CREATE TABLE iot_base_second
(
 second_index number(19,0) NOT NULL,
 TM           time(9) NOT NULL,
 S2           number(26,0),
 S3           number(26,0),
 S4           number(26,0),
 S5           number(26,0),
 S10          number(26,0),
 S15          number(26,0),
 S20          number(26,0),
 S30          number(26,0),
 M1           number(26,0),
 M2           number(26,0),
 M3           number(26,0),
 M5           number(26,0),
 M10          number(26,0),
 M15          number(26,0),
 M20          number(26,0),
 M30          number(26,0),
 H1           number(26,0),
 H2           number(26,0),
 H3           number(26,0),
 H4           number(26,0),
 H6           number(26,0),
 H12          number(26,0),
 S1M          number(1,0),
 S2M          number(1,0),
 S3M          number(1,0),
 S4M          number(1,0),
 S5M          number(1,0),
 S10M         number(1,0),
 S15M         number(1,0),
 S20M         number(1,0),
 S30M         number(1,0),
 M1M          number(1,0),
 M2M          number(1,0),
 M3M          number(1,0),
 M5M          number(1,0),
 M10M         number(1,0),
 M15M         number(1,0),
 M20M         number(1,0),
 M30M         number(1,0),
 H1M          number(1,0),
 H2M          number(1,0),
 H3M          number(1,0),
 H4M          number(1,0),
 H6M          number(1,0),
 H12M         number(1,0),
 D1M          number(1,0),
 hour_index   integer NOT NULL,
 minute_index integer NOT NULL,

 CONSTRAINT PK_1 PRIMARY KEY ( second_index )
)
COMMENT = 'The base second table holds 86400 rows and is designed to assist with standard  aggregating functions used in time series.  It essentially assists with using a simpler, set based approach to calculations involving time series values.';

-- ************************************** iot_base_millisecond
CREATE TABLE iot_base_millisecond
(
 ms_index number(19,0) NOT NULL,
 MS2      number(26,0),
 MS4      number(26,0),
 MS5      number(26,0),
 MS6      number(26,0),
 MS8      number(26,0),
 MS10     number(26,0),
 MS15     number(26,0),
 MS20     number(26,0),
 MS30     number(26,0),
 MS40     number(26,0),
 MS50     number(26,0),
 MS100    number(26,0),
 MS200    number(26,0),
 MS250    number(26,0),
 MS300    number(26,0),
 MS400    number(26,0),
 MS500    number(26,0),
 INCLUDE  number(1,0),
 MS2M     number(1,0),
 MS4M     number(1,0),
 MS5M     number(1,0),
 MS6M     number(1,0),
 MS8M     number(1,0),
 MS10M    number(1,0),
 MS15M    number(1,0),
 MS20M    number(1,0),
 MS30M    number(1,0),
 MS40M    number(1,0),
 MS50M    number(1,0),
 MS100M   number(1,0),
 MS200M   number(1,0),
 MS250M   number(1,0),
 MS300M   number(1,0),
 MS400M   number(1,0),
 MS500M   number(1,0),

 CONSTRAINT PK_1 PRIMARY KEY ( ms_index )
)
COMMENT = 'For millisecond level aggregations.  Note that there is one row added to this table that has null values - so it contains 1001 rows.';

-- ************************************** _base_day
CREATE TABLE iot_base_day
(
 day_index      integer NOT NULL,
 date_value     date NOT NULL,
 day_name       varchar NOT NULL,
 month_name     varchar NOT NULL,
 eom            date NOT NULL COMMENT 'end of month',
 year           integer NOT NULL,
 year_month     integer NOT NULL COMMENT '1-12',
 year_half      integer NOT NULL COMMENT '1 or 2',
 year_quarter   integer NOT NULL COMMENT '1, 2, 3, 4',
 year_week      integer NOT NULL,
 year_day       integer NOT NULL,
 days_in_month  integer NOT NULL,
 dofw_sun_start integer NOT NULL,
 dofw_sat_start integer NOT NULL,
 dofw_fri_start integer NOT NULL,
 dofw_thu_start integer NOT NULL,
 dofw_wed_start integer NOT NULL,
 dofw_tue_start integer NOT NULL,
 dofw_mon_start integer NOT NULL,
 eow_sun_start  date NOT NULL COMMENT 'end of week - ending Tuesday',
 eow_sat_start  date NOT NULL COMMENT 'end of week - ending Wednesday',
 eow_fri_start  date NOT NULL COMMENT 'end of week - ending Thursday',
 eow_thu_start  date NOT NULL COMMENT 'end of week - ending Friday',
 eow_wed_start  date NOT NULL COMMENT 'end of week - ending Saturday',
 eow_tue_start  date NOT NULL COMMENT 'end of week - ending Sunday',
 eow_mon_start  date NOT NULL COMMENT 'end of week - ending Monday',

 CONSTRAINT PK_1 PRIMARY KEY ( day_index )
)
COMMENT = 'Table for ALL days';


-- ************************************** iot_tag
CREATE or replace TABLE iot_tag
(
 hk_tag        binary NOT NULL,
 tagname       varchar NOT NULL,
 record_source varchar NOT NULL,
 data_type     varchar NOT NULL COMMENT 'text, number, timestamp, date',
 dimension     varchar COMMENT 'temperature, pressure, volume, level, flow rate, voltage, etc.',
 time_zone     varchar,
 measure_type  varchar COMMENT 'Standard Measure - Tubing pressure, tank level, Ambient Temperature, etc.  UDC (user defined Code)',
 dscr          varchar,
 unit_uid      integer,
 eng_min_val   number(38,10),
 eng_max_val   number(38,10),
 min_val       number(38,10),
 max_val       number(38,10),
 max_rate      number(38,0),
 sdt_deadband  number(38,10),
 load_ts       timestamp_tz NOT NULL DEFAULT current_timestamp(),
 dv_hashdiff   binary NOT NULL,

 CONSTRAINT PK_1 PRIMARY KEY ( hk_tag ),
 CONSTRAINT FK_34 FOREIGN KEY ( unit_uid ) REFERENCES iot_unit ( unit_uid )
);

-- ************************************** iot_tag_value
CREATE or replace TABLE iot_tag_value
(
 hk_tag        binary NOT NULL,
 tstamp        timestamp_tz NOT NULL,
 record_source varchar NOT NULL,
 val_number    float,
 val_text      varchar,
 quality       integer,
 d             date NOT NULL,
 unit_uid      integer,
 day_index     integer NOT NULL,
 second_index  number(19,0) NOT NULL,
 ms_index      number(19,0) NOT NULL,
 ep_seconds    number(14,0) NOT NULL,
 edit_comment  varchar,
 load_ts       timestamp_tz NOT NULL DEFAULT current_timestamp(),
 CONSTRAINT PK_1 PRIMARY KEY ( hk_tag, tstamp ),
 CONSTRAINT FK_39_2 FOREIGN KEY ( unit_uid ) REFERENCES iot_unit ( unit_uid ),
 CONSTRAINT FK_68_2 FOREIGN KEY ( second_index ) REFERENCES iot_base_second ( second_index ),
 CONSTRAINT FK_69_1 FOREIGN KEY ( hk_tag ) REFERENCES iot_tag ( hk_tag ),
 CONSTRAINT FK_70 FOREIGN KEY ( ms_index ) REFERENCES iot_base_millisecond ( ms_index ),
 CONSTRAINT FK_71 FOREIGN KEY ( day_index ) REFERENCES iot_base_day ( day_index )
);

insert into IOT_base_day (select
    n day_index,
    dateadd(day, n-1, to_date('1/1/1900', 'MM/DD/YYYY')) date_value,
    dayname(date_value) day_name,
    monthname(date_value) month_name,
    last_day(date_value) eom,
    year(date_value) year,
    month(date_value) year_month,
    case when year_month < 7 then 1 else 2 end year_half,
    case when year_month < 4 then 1 when year_month between 4 and 6 then 2 when year_month between 7 and 9 then 3 else 4 end year_quarter,
    week(date_value) year_week,
    day(date_value) year_day,
    dayofmonth(eom) days_in_month,
    dayofweek(date_value) dofw_sun,
    dayofweek(dateadd(day, 1, date_value)) dofw_sat,
    dayofweek(dateadd(day, 2, date_value)) dofw_fri,
    dayofweek(dateadd(day, 3, date_value)) dofw_thu,
    dayofweek(dateadd(day, 4, date_value)) dofw_wed,
    dayofweek(dateadd(day, 5, date_value)) dofw_tue,
    dayofweek(dateadd(day, 6, date_value)) dofw_mon,
    decode(dofw_sun, 0, date_value, dateadd(day, 7 - dofw_sun, date_value)) eow_sun,
    decode(dofw_sun, 0, date_value, dateadd(day, 7 - dofw_sat, date_value)) eow_sat,
    decode(dofw_fri, 0, date_value, dateadd(day, 7 - dofw_fri, date_value)) eow_fri,
    decode(dofw_thu, 0, date_value, dateadd(day, 7 - dofw_thu, date_value)) eow_thu,
    decode(dofw_fri, 0, date_value, dateadd(day, 7 - dofw_wed, date_value)) eow_wed,
    decode(dofw_fri, 0, date_value, dateadd(day, 7 - dofw_tue, date_value)) eow_tue,
    decode(dofw_fri, 0, date_value, dateadd(day, 7 - dofw_mon, date_value)) eow_mon
from
    (select row_number() over (order by seq4()) n from table(generator(rowcount => 100000))));
 
 
insert into IOT_base_millisecond (select
    n-1 ms_index,
    trunc((n - 1) / 2) ms2,
    trunc((n - 1) / 4) ms4,
    trunc((n - 1) / 5) ms5,
    trunc((n - 1) / 6) ms6,
    trunc((n - 1) / 8) ms8,
    trunc((n - 1) / 10) ms10,
    trunc((n - 1) / 15) ms15,
    trunc((n - 1) / 20) ms20,
    trunc((n - 1) / 30) ms30,
    trunc((n - 1) / 40) ms40,
    trunc((n - 1) / 50) ms50,
    trunc((n - 1) / 100) ms100,
    trunc((n - 1) / 200) ms200,
    trunc((n - 1) / 250) ms250,
    trunc((n - 1) / 300) ms300,
    trunc((n - 1) / 400) ms400,
    trunc((n - 1) / 500) ms500,
    1 include,
    iff(ms_index = 0, 0, iff(ms2 <> trunc((n - 2) / 2), 0, 1)) ms2m,
    iff(ms_index = 0, 0, iff(ms4 <> trunc((n - 2) / 4), 0, 1)) ms4m,
    iff(ms_index = 0, 0, iff(ms5 <> trunc((n - 2) / 5), 0, 1)) ms5m,
    iff(ms_index = 0, 0, iff(ms6 <> trunc((n - 2) / 6), 0, 1)) ms6m,
    iff(ms_index = 0, 0, iff(ms8 <> trunc((n - 2) / 8), 0, 1)) ms8m,
    iff(ms_index = 0, 0, iff(ms10 <> trunc((n - 2) / 10), 0, 1)) ms10m,
    iff(ms_index = 0, 0, iff(ms15 <> trunc((n - 2) / 15), 0, 1)) ms15m,
    iff(ms_index = 0, 0, iff(ms20 <> trunc((n - 2) / 20), 0, 1)) ms20m,
    iff(ms_index = 0, 0, iff(ms30 <> trunc((n - 2) / 30), 0, 1)) ms30m,
    iff(ms_index = 0, 0, iff(ms40 <> trunc((n - 2) / 40), 0, 1)) ms40m,
    iff(ms_index = 0, 0, iff(ms50 <> trunc((n - 2) / 50), 0, 1)) ms50m,
    iff(ms_index = 0, 0, iff(ms100 <> trunc((n - 2) / 100), 0, 1)) ms100m,
    iff(ms_index = 0, 0, iff(ms200 <> trunc((n - 2) / 200), 0, 1)) ms200m,
    iff(ms_index = 0, 0, iff(ms250 <> trunc((n - 2) / 250), 0, 1)) ms250m,
    iff(ms_index = 0, 0, iff(ms300 <> trunc((n - 2) / 300), 0, 1)) ms300m,
    iff(ms_index = 0, 0, iff(ms400 <> trunc((n - 2) / 400), 0, 1)) ms400m,
    iff(ms_index = 0, 0, iff(ms500 <> trunc((n - 2) / 500), 0, 1)) ms500m
from
    (select row_number() over (order by seq4()) n from table(generator(rowcount => 1000)))
union all
    select 0 ms_index,
    null ms2,
    null ms4,
    null ms5,
    null ms6,
    null ms8,
    null ms10,
    null ms15,
    null ms22,
    null ms30,
    null ms40,
    null ms50,
    null ms100,
    null ms200,
    null ms250,
    null ms300,
    null ms400,
    null ms500,
    0 include,
    null ms2m,
    null ms4m,
    null ms5m,
    null ms6m,
    null ms8m,
    null ms10m,
    null ms15m,
    null ms20m,
    null ms30m,
    null ms40m,
    null ms50m,
    null ms100m,
    null ms200m,
    null ms250m,
    null ms300m,
    null ms400m,
    null ms500m
);

insert into IOT_base_second (
select
    n-1 second_index,
    to_time(to_char(n-1)) tm,
    trunc((n - 1) / 2) s2,
    trunc((n - 1) / 3) s3,
    trunc((n - 1) / 4) s4,
    trunc((n - 1) / 5) s5,
    trunc((n - 1) / 10) s10,
    trunc((n - 1) / 15) s15,
    trunc((n - 1) / 20) s20,
    trunc((n - 1) / 30) s30,
    trunc((n - 1) / 60) m1,
    trunc((n - 1) / (2 * 60)) m2,
    trunc((n - 1) / (3 * 60)) m3,    
    trunc((n - 1) / (5 * 60)) m5,
    trunc((n - 1) / (10 * 60)) m10,
    trunc((n - 1) / (15 * 60)) m15,
    trunc((n - 1) / (20 * 60)) m20,
    trunc((n - 1) / (30 * 60)) m30,
    trunc((n - 1) / (1 * 60 * 60)) h1,
    trunc((n - 1) / (2 * 60 * 60)) h2,
    trunc((n - 1) / (3 * 60 * 60)) h3,
    trunc((n - 1) / (4 * 60 * 60)) h4,
    trunc((n - 1) / (6 * 60 * 60)) h6,
    trunc((n - 1) / (12 * 60 * 60)) h12,
    0 s1m,
    iff(mod(n-1, 2) = 0, 0, 1) s2m,
    iff(mod(n-1, 3) = 0, 0, 1) s3m,
    iff(mod(n-1, 4) = 0, 0, 1) s4m,
    iff(mod(n-1, 5) = 0, 0, 1) s5m,
    iff(mod(n-1, 10) = 0, 0, 1) s10m,
    iff(mod(n-1, 15) = 0, 0, 1) s15m,
    iff(mod(n-1, 20) = 0, 0, 1) s20m,
    iff(mod(n-1, 30) = 0, 0, 1) s30m,
    iff(mod(n-1, 60) = 0, 0, 1) m1m,
    iff(mod(n-1, 120) = 0, 0, 1) m2m,
    iff(mod(n-1, 180) = 0, 0, 1) m3m,
    iff(mod(n-1, 300) = 0, 0, 1) m5m,
    iff(mod(n-1, 600) = 0, 0, 1) m10m,
    iff(mod(n-1, 900) = 0, 0, 1) m15m,
    iff(mod(n-1, 1200) = 0, 0, 1) m20m,
    iff(mod(n-1, 1800) = 0, 0, 1) m30m,
    iff(mod(n-1, 3600) = 0, 0, 1) h1m,
    iff(mod(n-1, 7200) = 0, 0, 1) h2m,
    iff(mod(n-1, 10800) = 0, 0, 1) h3m,
    iff(mod(n-1, 14400) = 0, 0, 1) h4m,
    iff(mod(n-1, 21600) = 0, 0, 1) h6m,
    iff(mod(n-1, 43200) = 0, 0, 1) h12m,
    iff(mod(n-1, 86400) = 0, 0, 1) d1m,
    hour(tm) hour_index,
    minute(tm) minute_index
from
    (select row_number() over (order by seq4()) n from table(generator(rowcount => 86400)))
);


select * from iot_tag;
insert into iot_tag (tagname, record_source, hk_tag, data_type, dv_hashdiff) (select 'SIMPLE1', 'DEMO' , md5_binary('DEMO^SIMPLE1'), 'NUMBER', md5_binary('NUMBER'));
insert into iot_tag (tagname, record_source, hk_tag, data_type, dv_hashdiff) (select 'NOISY', 'DEMO' , md5_binary('DEMO^NOISY'), 'NUMBER', md5_binary('NUMBER'));
insert into iot_tag (tagname, record_source, hk_tag, data_type, dv_hashdiff) (select 'INCREASING', 'DEMO' , md5_binary('DEMO^INCREASING'), 'NUMBER', md5_binary('NUMBER'));


create or replace view iot_tag_value_dv as
(select 
    hk_tag,
    tagname,
    tstamp,
    record_source,
    val_number,
    val_text,
    quality,
    d,
    unit_name,
    unit_uid,
    day_index,
    second_index,
    ms_index,
    ep_seconds
from (
    select
        v.hk_tag,
        t.tagname,
        v.tstamp,
        v.record_source,
        v.val_number,
        v.val_text,
        v.quality,
        v.d,
        u.unit_name,
        v.unit_uid,
        v.day_index,
        v.second_index,
        v.ms_index,
        v.ep_seconds,
        v.edit_comment,
        v.load_ts,
        lead(v.load_ts) over (partition by v.hk_tag, v.tstamp order by v.load_ts) next_version
    from
        iot_tag_value v inner join iot_tag t on v.hk_tag = t.hk_tag
        left join iot_unit u on t.unit_uid = u.unit_uid)
    where next_version is null);

select * from iot_tag_value_dv;

set buckets = 5;
set sig = 'SIMPLE1';

select 'raw' sig_type, x, y -20 y from signals where id = $sig
union all 
select 'ds' sig_type, x, y from 
(
with 
vals as ( -- get subset of values from table that has all signals
    select 
        x,
        y,
        rank() over (order by x) idx,
    from 
        signals
    where 
        id = $sig),
mx as ( -- one line of stats needed to do the calc
    select 
        max(idx) m, 
        round(m / $buckets + .5) group_count 
    from 
        vals),
group_values as ( -- generate a grouping set based on the divider num rows / number of buckets
    select
        v.x,
        v.y,
        v.idx,
        round(v.idx / $buckets + .5, 0) group_n
    from
        vals v,
        mx
    where
        v.idx > 1 and v.idx < mx.m
    union all
        select x, y, 1, 0 group_n from vals where idx = 1 -- always get the first sample in its own group
    union all
        select vals.x, vals.y, mx.m idx, mx.group_count group_n from vals, mx where vals.idx = mx.m), -- always have the last sample in its own group
group_averages as (
    select -- required by algorithm for third bucket
        group_n,
        avg(x) xavg,
        avg(y) yavg
    from
        group_values
    group by 
        group_n),
ab_group_values as ( -- pre calculate every possible 3 group with all possible bucket 1 values, each bucket 2 value and the average of bucket 3s
    select
        b.group_n,
        a.x x1, 
        a.y y1,
        b.x x2,
        b.y y2,
        av.xavg x3,
        av.yavg y3,
        abs(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2) / 2 area,
        lead(area) over (partition by b.group_n order by b.group_n, area) next_area
    from
        group_values a,
        group_values b,
        group_averages av
    where
        a.group_n = b.group_n - 1
        and b.group_n = av.group_n
    )
select 
    group_n,
    x2 x,
    y2 y
from
    ab_group_values
where
    next_area is null -- pick the largest in each group
union all
select -- throw in the first value
    group_n,
    xavg x,
    yavg y
from
    group_averages
where
    group_n = 0)    
order by sig_type, x;
